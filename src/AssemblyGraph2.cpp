// Shasta.
#include "AssemblyGraph2.hpp"
#include "Anchor.hpp"
#include "AssemblerOptions.hpp"
#include "deduplicate.hpp"
#include "findLinearChains.hpp"
#include "LocalAssembly2.hpp"
#include "orderPairs.hpp"
#include "performanceLog.hpp"
#include "rle.hpp"
#include "Tangle2.hpp"
#include "TransitionGraph.hpp"
#include "SimpleDetangler.hpp"
#include "TrivialDetangler.hpp"
using namespace shasta;

// Boost libraries.
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/graph/adj_list_serialize.hpp>

// Standard library.
#include <chrono.hpp>
#include <fstream.hpp>
#include <list>
#include <map>
#include "tuple.hpp"

// Explicit instantiation.
#include "MultithreadedObject.tpp"
template class MultithreadedObject<AssemblyGraph2>;


// Initial construction from the TransitionGraph.
AssemblyGraph2::AssemblyGraph2(
    const Anchors& anchors,
    const TransitionGraph& transitionGraph,
    const AssemblerOptions& assemblerOptions) :
    MappedMemoryOwner(anchors),
    MultithreadedObject<AssemblyGraph2>(*this),
    anchors(anchors),
    assemblerOptions(assemblerOptions)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    // Find linear chains of vertices in the TransitionGraph.
    vector< std::list<TransitionGraph::vertex_descriptor> > chains;
    findLinearVertexChains(transitionGraph, chains);
    // cout << "Found " << chains.size() << " linear chains in the TransitionGraph." << endl;

    // Maps filled n while creating vertices and used to create edges.
    std::map<TransitionGraph::vertex_descriptor, AssemblyGraph2::vertex_descriptor> firstVertexMap;
    std::map<AssemblyGraph2::vertex_descriptor, TransitionGraph::vertex_descriptor> lastVertexMap;

    // Each chain generates an AssemblyGraph2Vertex.
    // To be able to create edges below, we keep a map that gives us the
    // AssemblyGraph2::vertex_descriptor corresponding to the chain
    // that begins at a given TransitionGraph::vertex-descriptor.
    for(const std::list<TransitionGraph::vertex_descriptor>& chain: chains) {
        const vertex_descriptor va = add_vertex(AssemblyGraph2Vertex(nextVertexId++), assemblyGraph2);
        AssemblyGraph2Vertex& vertex = assemblyGraph2[va];
        firstVertexMap.insert(make_pair(chain.front(), va));
        lastVertexMap.insert(make_pair(va, chain.back()));
        for(const TransitionGraph::vertex_descriptor vt: chain) {
            const AnchorPair& anchorPair = transitionGraph[vt].anchorPair;
            const uint64_t offset = anchorPair.getAverageOffset(anchors);
            vertex.push_back(AssemblyGraph2VertexStep(anchorPair, offset));
        }
    }
    chains.clear();
    chains.shrink_to_fit();


    // To generate edges, we loop over vertices and use the maps created above.
    BGL_FORALL_VERTICES(v0a, assemblyGraph2, AssemblyGraph2) {

        // Find the TransitionGraph vertex at the end of the chain than generated this vertex.
        auto itLast  = lastVertexMap.find(v0a);
        SHASTA_ASSERT(itLast != lastVertexMap.end());
        const TransitionGraph::vertex_descriptor v0t = itLast->second;

        // Loop over out-edges of v0t in the TransitionGraph.
        BGL_FORALL_OUTEDGES(v0t, e, transitionGraph, TransitionGraph) {
            const TransitionGraph::vertex_descriptor v1t = target(e, transitionGraph);

            // Find the AssemblyGraph2Vertex generated by the chain that begins here.
            auto itFirst  = firstVertexMap.find(v1t);
            SHASTA_ASSERT(itFirst != firstVertexMap.end());
            const AssemblyGraph2::vertex_descriptor v1a = itFirst->second;

            // Add the edge.
            add_edge(v0a, v1a, assemblyGraph2);
        }
    }

    // Check that all vertices and edges of the TransitionGraph are accounted for.
    uint64_t vertexCount = 0;
    uint64_t edgeCount = num_edges(assemblyGraph2);
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        vertexCount += assemblyGraph2[v].size();
        edgeCount += (assemblyGraph2[v].size() - 1);
    }
    SHASTA_ASSERT(vertexCount == num_vertices(transitionGraph));
    SHASTA_ASSERT(edgeCount == num_edges(transitionGraph));

    // Check that all is good.
    check();
}



// Deserialize constructor.
AssemblyGraph2::AssemblyGraph2(
    const Anchors& anchors,
    const AssemblerOptions& assemblerOptions,
    const string& stage) :
    MappedMemoryOwner(anchors),
    MultithreadedObject<AssemblyGraph2>(*this),
    anchors(anchors),
    assemblerOptions(assemblerOptions)
{
    load(stage);
}



void AssemblyGraph2::check() const
{
    performanceLog << timestamp << "AssemblyGraph2 check begins." << endl;
    const AssemblyGraph2& assemblyGraph2 = *this;

    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        assemblyGraph2[v].check(anchors);
    }
    BGL_FORALL_EDGES(e, assemblyGraph2, AssemblyGraph2) {
        check(e);
    }

    performanceLog << timestamp << "AssemblyGraph2 check ends." << endl;
}



void AssemblyGraph2Vertex::check(const Anchors& anchors) const
{

    // The AnchorPairs of this vertex must be adjacent to each other.
    for(uint64_t i1=1; i1<size(); i1++) {
        const uint64_t i0 = i1 - 1;

        const AssemblyGraph2VertexStep& step0 = (*this)[i0];
        const AssemblyGraph2VertexStep& step1 = (*this)[i1];

        /*
        cout <<
            i0 << " " <<
            i1 << " " <<
            step0.anchorPair.anchorIdA << " " <<
            step0.anchorPair.anchorIdB << " " <<
            step1.anchorPair.anchorIdA << " " <<
            step1.anchorPair.anchorIdB << endl;
        */

        SHASTA_ASSERT(step0.anchorPair.anchorIdB == step1.anchorPair.anchorIdA);
    }

    // The offsets must be correct.
    for(const AssemblyGraph2VertexStep& step: *this) {
        SHASTA_ASSERT(step.offset == step.anchorPair.getAverageOffset(anchors));
    }
}



void AssemblyGraph2::check(edge_descriptor e) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    const vertex_descriptor v0 = source(e, assemblyGraph2);
    const vertex_descriptor v1 = target(e, assemblyGraph2);

    const AssemblyGraph2Vertex& vertex0 = assemblyGraph2[v0];
    const AssemblyGraph2Vertex& vertex1 = assemblyGraph2[v1];

    SHASTA_ASSERT(vertex0.back().anchorPair.anchorIdB == vertex1.front().anchorPair.anchorIdA);
}



void AssemblyGraph2::write(const string& stage)
{
    save(stage);
    writeGfa("AssemblyGraph2-" + stage + ".gfa");
    writeGraphviz("AssemblyGraph2-" + stage + ".dot");
}



void AssemblyGraph2::writeGfa(const string& fileName) const
{
    performanceLog << timestamp << "GFA output begins for " << fileName << endl;
    ofstream gfa(fileName);
    writeGfa(gfa);
    performanceLog << timestamp << "GFA output ends for " << fileName << endl;
}



void AssemblyGraph2::writeGfa(ostream& gfa) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    // Write the header line.
    gfa << "H\tVN:Z:1.0\n";

    // Each vertex generates a gfa segment.
    vector<shasta::Base> sequence;
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];

        // Record type.
        gfa << "S\t";

        // Name.
        gfa << vertex.id << "\t";

        // Sequence.
        if(vertex.wasAssembled) {
            vertex.getSequence(sequence);
            copy(sequence.begin(), sequence.end(), ostream_iterator<shasta::Base>(gfa));
            gfa << "\t";
            gfa << "LN:i:" << sequence.size() << "\n";
        } else {
            gfa << "*\t";
            gfa << "LN:i:" << vertex.offset() << "\n";
        }
    }



    // Each edge generates a gfa link.
    BGL_FORALL_EDGES(e, assemblyGraph2, AssemblyGraph2) {

        const vertex_descriptor v0 = source(e, assemblyGraph2);
        const vertex_descriptor v1 = target(e, assemblyGraph2);

        const AssemblyGraph2Vertex& vertex0 = assemblyGraph2[v0];
        const AssemblyGraph2Vertex& vertex1 = assemblyGraph2[v1];

        gfa <<
            "L\t" <<
            vertex0.id << "\t+\t" <<
            vertex1.id << "\t+\t*\n";
    }

}



void AssemblyGraph2::writeGraphviz(const string& fileName) const
{
    performanceLog << timestamp << "Grahviz output begins for " << fileName << endl;
    ofstream dot(fileName);
    writeGraphviz(dot);
    performanceLog << timestamp << "Grahviz output ends for " << fileName << endl;

}



void AssemblyGraph2::writeGraphviz(ostream& dot) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    dot << "digraph AssemblyGraph2 {\n";

    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
        dot << vertex.id << "[label=\"" <<
            vertex.id << "\\n" <<
            (vertex.wasAssembled ? vertex.sequenceLength() : vertex.offset()) << "\"];\n";
    }

    BGL_FORALL_EDGES(e, assemblyGraph2, AssemblyGraph2) {

        const vertex_descriptor v0 = source(e, assemblyGraph2);
        const vertex_descriptor v1 = target(e, assemblyGraph2);

        const AssemblyGraph2Vertex& vertex0 = assemblyGraph2[v0];
        const AssemblyGraph2Vertex& vertex1 = assemblyGraph2[v1];

        dot << vertex0.id << "->" << vertex1.id << ";\n";
    }

    dot << "}\n";
}



void AssemblyGraph2::writeFasta(const string& fileName) const
{
    performanceLog << timestamp << "Fasta output begins for " << fileName << endl;

    const AssemblyGraph2& assemblyGraph2 = *this;;
    ofstream fasta(fileName);

    vector<shasta::Base> sequence;
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
        vertex.getSequence(sequence);

        fasta << ">" << vertex.id << "\n";
        copy(sequence.begin(), sequence.end(), ostream_iterator<shasta::Base>(fasta));
        fasta << "\n";
    }

    performanceLog << timestamp << "Fasta output ends for " << fileName << endl;
}




uint64_t AssemblyGraph2Vertex::offset() const
{
    uint64_t sum = 0;
    for(const AssemblyGraph2VertexStep& step: *this) {
        sum += step.offset;
    }
    return sum;
}



// Assemble sequence for all vertices.
void AssemblyGraph2::assembleAll(uint64_t threadCount)
{
    performanceLog << timestamp << "Sequence assembly begins." << endl;
    const AssemblyGraph2& assemblyGraph2 = *this;

    verticesToBeAssembled.clear();
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        verticesToBeAssembled.push_back(v);
    }
    assemble(threadCount);
    performanceLog << timestamp << "Sequence assembly ends." << endl;
}



// Assemble sequence for all vertices in the verticesToBeAssembled vector.
// This fills in the stepsToBeAssembled with all steps of those edges,
// then assembles each of the steps in parallel.
void AssemblyGraph2::assemble(uint64_t threadCount)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    stepsToBeAssembled.clear();
    for(const vertex_descriptor v: verticesToBeAssembled) {
        AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
        for(uint64_t i=0; i<vertex.size(); i++) {
            stepsToBeAssembled.push_back(make_pair(v, i));
        }
    }

    const uint64_t batchCount = 1;
    setupLoadBalancing(stepsToBeAssembled.size(), batchCount);
    runThreads(&AssemblyGraph2::assembleThreadFunction, threadCount);

    // Mark them as assembled.
    for(const vertex_descriptor v: verticesToBeAssembled) {
        assemblyGraph2[v].wasAssembled = true;
    }

    verticesToBeAssembled.clear();
    stepsToBeAssembled.clear();
}



void AssemblyGraph2::assembleThreadFunction(uint64_t threadId)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    ofstream out("Assemble-Thread-" + to_string(threadId) + ".txt");

    // Loop over all batches assigned to this thread.
    uint64_t begin, end;
    while(getNextBatch(begin, end)) {

        // Loop over all assembly steps assigned to this batch.
        for(uint64_t j=begin; j!=end; j++) {
            if((j % 1000) == 0) {
                std::lock_guard<std::mutex> lock(mutex);
                performanceLog << timestamp << j << "/" << stepsToBeAssembled.size() << endl;
            }

            const auto& p = stepsToBeAssembled[j];
            const vertex_descriptor v = p.first;
            const uint64_t i = p.second;
            AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
            SHASTA_ASSERT(i < vertex.size());
            out << "Begin " << vertex.id << "," << i << endl;
            const auto t0 = steady_clock::now();
            assembleStep(v, i);
            const auto t1 = steady_clock::now();
            out << "End " << vertex.id << "," << i << "," << seconds(t1-t0) << endl;
        }
    }
}



// Assemble sequence for the specified vertex.
void AssemblyGraph2::assemble(vertex_descriptor v, uint64_t threadCount)
{
    verticesToBeAssembled.clear();
    verticesToBeAssembled.push_back(v);
    assemble(threadCount);
}



// Assemble sequence for step i of the specified vertex.
// This is the lowest level sequence assembly function and is not multithreaded.
// It runs a LocalAssembly2 on the AnchorPair for that step.
void AssemblyGraph2::assembleStep(vertex_descriptor v, uint64_t i)
{
    AssemblyGraph2& assemblyGraph2 = *this;
    AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
    AssemblyGraph2VertexStep& step = vertex[i];

    // Run the LocalAssembly2.
    ofstream html;  // Not open, so no html output takes place.
    LocalAssembly2 localAssembly(
        anchors, html, false,
        assemblerOptions.aDrift,
        assemblerOptions.bDrift,
        step.anchorPair);
    localAssembly.run(false, assemblerOptions.localAssemblyOptions.maxAbpoaLength);
    localAssembly.getSequence(step.sequence);

}



void AssemblyGraph2Vertex::getSequence(vector<Base>& sequence) const
{
    SHASTA_ASSERT(wasAssembled);
    sequence.clear();
    for(const auto& step: *this) {
        copy(step.sequence.begin(), step.sequence.end(), back_inserter(sequence));
    }
}



uint64_t AssemblyGraph2Vertex::sequenceLength() const
{
    SHASTA_ASSERT(wasAssembled);
    uint64_t length = 0;
    for(const auto& step: *this) {
        length += step.sequence.size();
    }
    return length;
}



// Detangle, phase, assemble sequence, output.
void AssemblyGraph2::run(uint64_t threadCount)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    // Output of the initial AssemblyGraph2.
    cout << "The initial AssemblyGraph2 has " << num_vertices(assemblyGraph2) <<
        " vertices and " << num_edges(assemblyGraph2) << " edges." << endl;
    write("A");

    // Bubble cleanup.
    bubbleCleanup(threadCount);
    compress();
    cout << "After bubble cleanup, the AssemblyGraph2 has " << num_vertices(assemblyGraph2) <<
        " vertices and " << num_edges(assemblyGraph2) << " edges." << endl;
    write("B");
    check();



    // Detangling.
    TrivialDetangler trivialDetangler(assemblerOptions.assemblyGraphOptions.minCommonCoverage);

    detangleVertices(trivialDetangler);
    check();
    compress();
    cout << "After TrivialDetangler, the AssemblyGraph2 has " << num_vertices(assemblyGraph2) <<
        " vertices and " << num_edges(assemblyGraph2) << " edges." << endl;
    write("C");

    SimpleDetangler simpleDetangler(3, 2);
    detangleVertices(simpleDetangler);
    write("D");
    check();
    compress();
    cout << "After SimpleDetangler, the AssemblyGraph2 has " << num_vertices(assemblyGraph2) <<
        " vertices and " << num_edges(assemblyGraph2) << " edges." << endl;
    write("E");


    throw runtime_error("Skipping sequence assembly.");

    // Sequence assembly.
    performanceLog << timestamp << "Sequence assembly begins." << endl;
    assembleAll(threadCount);
    performanceLog << timestamp << "Sequence assembly ends." << endl;

    // Final output.
    write("Z");
    writeFasta("AssemblyGraph2-Z.fasta");

}



void AssemblyGraph2::bubbleCleanup(uint64_t threadCount)
{
    while(bubbleCleanupIteration(threadCount) > 0)
    {

    }
    clearSequence();

}



uint64_t AssemblyGraph2::bubbleCleanupIteration(uint64_t threadCount)
{
    performanceLog << timestamp << "Bubble cleanup begins." << endl;

    const bool debug = false;
    AssemblyGraph2& assemblyGraph2 = *this;

    vector<Bubble> allBubbles;
    findBubbles(allBubbles);

    // Histogram bubbles by ploidy.
    {
        vector<uint64_t> histogram;
        for(const Bubble& bubble: allBubbles) {
            const uint64_t ploidy = bubble.chains.size();
            if(histogram.size() <= ploidy) {
                histogram.resize(ploidy + 1, 0);
            }
            ++histogram[ploidy];
        }
        for(uint64_t ploidy=0; ploidy<histogram.size(); ploidy++) {
            const uint64_t frequency = histogram[ploidy];
            if(frequency > 0) {
                cout << "Found " << frequency << " bubbles of ploidy " << ploidy << endl;
            }
        }
    }


    // If we decide to remove a Bubble, we have to replace it with a
    // new vertex with an AnchorPair bridging between v0 and v1 of that Bubble.
    // This will only be possible if the bubble is sufficiently short
    // and there are enough common reads between v0 and v1.
    // If not, we will leave the bubble alone.
    // Figure out what Bubble satisfy this condition.
    vector< pair<Bubble, AnchorPair> > candidateBubbles;
    for(const Bubble& bubble: allBubbles) {
        if(debug) {
            cout << "Analyzing bubble with ploidy " << bubble.chains.size() << ": "
                << assemblyGraph2[bubble.v0].id;

            for(const vector<vertex_descriptor>& chain: bubble.chains) {
                cout << " (";
                for(uint64_t i=0; i<chain.size(); i++) {
                    cout << assemblyGraph2[chain[i]].id;
                    if(i == chain.size() - 1) {
                        cout << ")";
                    } else {
                        cout << ",";
                    }
                }
            }
            cout << " " << assemblyGraph2[bubble.v1].id << endl;
        }

        // Get the last AnchorPair of the source vertex and the first AnchorPair
        // of the target vertex, and the corresponding AnchorIds.
        const AnchorPair& anchorPair0 = assemblyGraph2[bubble.v0].back().anchorPair;
        const AnchorPair& anchorPair1 = assemblyGraph2[bubble.v1].front().anchorPair;
        // const AnchorId anchorId0A = anchorPair0.anchorIdA;
        const AnchorId anchorId0B = anchorPair0.anchorIdB;
        const AnchorId anchorId1A = anchorPair1.anchorIdA;
        // const AnchorId anchorId1B = anchorPair0.anchorIdB;

        AnchorPair bridgeAnchorPair(anchors, anchorId0B, anchorId1A, false);

        if(debug) {
            cout << "Must bridge between anchors " <<
                anchorIdToString(anchorId0B) << " " <<
                anchorIdToString(anchorId1A) << ", common count " <<
                bridgeAnchorPair.orientedReadIds.size() << endl;
        }

        // If coverage of the bridgeAnchorPair is low, we can't remove this bubble.
        if(bridgeAnchorPair.orientedReadIds.size() < assemblerOptions.assemblyGraphOptions.bubbleCleanupMinCommonCount) {
            if(debug) {
                cout << "This bubble will not be removed due to insufficient coverage when bridging." << endl;
            }
            continue;
        }

        // Coverage of the bridgeAnchorPair is sufficient. But we only want to include
        // OrientedReadIds that appear in at least one side of the Bubble.
        vector<OrientedReadId> bubbleOrientedReadIds;
        for(const vector<vertex_descriptor>& chain: bubble.chains) {
            for(const vertex_descriptor v: chain) {
                const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
                for(const AssemblyGraph2VertexStep& step: vertex) {
                    const AnchorPair& anchorPair = step.anchorPair;
                    copy(anchorPair.orientedReadIds.begin(), anchorPair.orientedReadIds.end(),
                        back_inserter(bubbleOrientedReadIds));
                }
            }
        }
        deduplicate(bubbleOrientedReadIds);
        if(debug) {
            cout << "Vertices internal to this bubble use " << bubbleOrientedReadIds.size() <<
                " distinct oriented reads." << endl;
        }

        // We want use the OrientedReadIds that appear in both bubbleOrientedReadIds
        // and the bridgeAnchorPair.
        vector<OrientedReadId> orientedReadIds;
        std::set_intersection(
            bridgeAnchorPair.orientedReadIds.begin(), bridgeAnchorPair.orientedReadIds.end(),
            bubbleOrientedReadIds.begin(), bubbleOrientedReadIds.end(),
            back_inserter(orientedReadIds));
        bridgeAnchorPair.orientedReadIds = orientedReadIds;
        if(debug) {
            cout << "The bridge AnchorPair will use " << bridgeAnchorPair.orientedReadIds.size() <<
                " oriented reads." << endl;
        }

        // If coverage of the bridgeAnchorPair is low, we can't remove this bubble.
        if(bridgeAnchorPair.orientedReadIds.size() < assemblerOptions.assemblyGraphOptions.bubbleCleanupMinCommonCount) {
            if(debug) {
                cout << "This bubble will not be removed due to insufficient coverage when bridging." << endl;
            }
            continue;
        }

        // Add this Bubble to our candidates for removal.
        candidateBubbles.push_back(make_pair(bubble, bridgeAnchorPair));

    }

    if(debug) {
        cout << "Found " << candidateBubbles.size() <<
            " bubbles that are candidates for removal." << endl;
    }



    // Assemble sequence in the vertices internal to the candidate bubbles.
    verticesToBeAssembled.clear();
    for(const auto& p: candidateBubbles) {
        const Bubble& bubble = p.first;
        for(const vector<vertex_descriptor>& chain: bubble.chains) {
            for(const vertex_descriptor v: chain) {
                const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
                if(not vertex.wasAssembled) {
                    verticesToBeAssembled.push_back(v);
                }
            }
        }
    }
    performanceLog << timestamp << "Sequence assembly for bubble cleanup begins." << endl;
    assemble(threadCount);
    performanceLog << timestamp << "Sequence assembly for bubble cleanup ends." << endl;



    // Now that we have sequence for the candidate bubbles, we can decide
    // which ones should be removed.
    vector< vector<shasta::Base> > sequences;
    uint64_t removedCount = 0;
    for(const auto& p: candidateBubbles) {
        const Bubble& bubble = p.first;

        // Gather the sequences of all the sides of this bubble
        sequences.clear();
        for(const vector<vertex_descriptor>& chain: bubble.chains) {
            sequences.emplace_back();
            vector<shasta::Base>& sequence = sequences.back();
            for(const vertex_descriptor v: chain) {
                const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
                SHASTA_ASSERT(vertex.wasAssembled);
                for(const AssemblyGraph2VertexStep& step: vertex) {
                    copy(step.sequence.begin(), step.sequence.end(), back_inserter(sequence));
                }
            }
        }

        if(debug) {
            cout << "Sequences for bubble " << assemblyGraph2[bubble.v0].id <<
                " ... " << assemblyGraph2[bubble.v1].id << endl;
            for(uint64_t i=0; i<sequences.size(); i++) {
                const vector<shasta::Base>& sequence = sequences[i];
                cout << ">" << i << " " << sequence.size() << "\n";
                copy(sequence.begin(), sequence.end(), ostream_iterator<shasta::Base>(cout));
                cout << endl;
            }

        }

        // This bubble can be removed if all the RLE sequences are identical.
        bool allRawSequenceAreEqual = true;
        for(uint64_t i=1; i<sequences.size(); i++) {
            if(sequences[i] != sequences[0]) {
                allRawSequenceAreEqual = false;
                break;
            }
        }
        if(debug) {
            if(allRawSequenceAreEqual) {
                cout << "The " << sequences.size() << " raw sequences are all equal." << endl;
            } else {
                cout << "The " << sequences.size() << " raw sequences are not all equal." << endl;
            }
        }


        // If all raw sequence are equal, we can remove the bubble without checking the RLE sequences.
        // Otherwise we have to also check the RLE sequences.
        bool removeBubble = allRawSequenceAreEqual;
        if(not allRawSequenceAreEqual) {

            // Compute the RLE sequences.
            vector< vector<shasta::Base> > rleSequences;
            for(const vector<shasta::Base>& sequence: sequences) {
                rleSequences.emplace_back();
                rle(sequence, rleSequences.back());
            }

            // Check if they are all the same.
            bool allRleSequenceAreEqual = true;
            for(uint64_t i=1; i<sequences.size(); i++) {
                if(rleSequences[i] != rleSequences[0]) {
                    allRleSequenceAreEqual = false;
                    break;
                }
            }

            if(debug) {
                if(allRleSequenceAreEqual) {
                    cout << "The " << sequences.size() << " RLE sequences are all equal." << endl;
                } else {
                    cout << "The " << sequences.size() << " RLE sequences are not all equal." << endl;
                }
            }

            removeBubble = allRleSequenceAreEqual;

        }

        if(debug) {
            if(removeBubble) {
                cout << "This bubble will be removed." << endl;
            } else {
                cout << "This bubble will not be removed." << endl;
            }
        }


        // Remove the bubble, if we decided that we can do that.
        if(removeBubble) {
            ++removedCount;

            // Remove the vertices of the bubble.
            for(const vector<vertex_descriptor>& chain: bubble.chains) {
                for(const vertex_descriptor v: chain) {
                    clear_vertex(v, assemblyGraph2);
                    remove_vertex(v, assemblyGraph2);
                }
            }

            // Add a new vertex with a single step to replace the bubble.
            const vertex_descriptor v2 = add_vertex(AssemblyGraph2Vertex(nextVertexId++), assemblyGraph2);
            AssemblyGraph2Vertex& vertex2 = assemblyGraph2[v2];
            const AnchorPair& anchorPair = p.second;
            const uint64_t offset = anchorPair.getAverageOffset(anchors);
            vertex2.emplace_back(anchorPair, offset);

            // Add the edges.
            add_edge(bubble.v0, v2, assemblyGraph2);
            add_edge(v2, bubble.v1, assemblyGraph2);
        }

    }

    cout << "Out of " << allBubbles.size() << " bubbles, " <<
        candidateBubbles.size() << " were candidate for removal and " <<
        removedCount << " were actually removed." << endl;

    performanceLog << timestamp << "Bubble cleanup ends." << endl;
    cout << "Bubble cleanup iteration removed " << removedCount << " bubbles." << endl;

    return removedCount;
}



void AssemblyGraph2::findBubbles(vector<Bubble>& bubbles) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    // To find bubbles, find linear chains of edges.
    // Each set of linear chains that begin and end at the same (v0, v1)
    // and has size at least 2 forms a bubble.
    vector< vector<edge_descriptor> > linearChains;
    findLinearChains(assemblyGraph2, 0, linearChains);
    const uint64_t linearChainCount = linearChains.size();

    // We need to gather linear chains with the same (v0, v1).
    class LinearChainInfo {
    public:
        vertex_descriptor v0;
        vertex_descriptor v1;
        uint64_t linearChainId; // Index in the linearChains vector.
        bool operator<(const LinearChainInfo& that) const
        {
            return tie(v0, v1, linearChainId) < tie(that.v0, that.v1, that.linearChainId);
        }
    };
    vector<LinearChainInfo> linearChainInfos(linearChainCount);
    for(uint64_t linearChainId=0; linearChainId<linearChainCount; linearChainId++) {
        const vector<edge_descriptor>& linearChain = linearChains[linearChainId];
        LinearChainInfo& linearChainInfo = linearChainInfos[linearChainId];
        linearChainInfo.v0 = source(linearChain.front(), assemblyGraph2);
        linearChainInfo.v1 = target(linearChain.back(), assemblyGraph2);
        linearChainInfo.linearChainId = linearChainId;
    }
    sort(linearChainInfos.begin(), linearChainInfos.end());



    // Loop over streaks with the same (v0, v1).
    // Each streak of length at least 2 generates a Bubble.
    bubbles.clear();
    for(uint64_t streakBegin=0; streakBegin<linearChainCount; /* Increment later */) {
        const vertex_descriptor v0 = linearChainInfos[streakBegin].v0;
        const vertex_descriptor v1 = linearChainInfos[streakBegin].v1;

        uint64_t streakEnd = streakBegin + 1;
        for(; streakEnd<linearChainCount; streakEnd++) {
            if(linearChainInfos[streakEnd].v0 != v0) {
                break;
            }
            if(linearChainInfos[streakEnd].v1 != v1) {
                break;
            }
        }

        const uint64_t ploidy = streakEnd - streakBegin;
        if(ploidy > 1) {
            bubbles.push_back(Bubble());
            Bubble& bubble = bubbles.back();
            bubble.v0 = v0;
            bubble.v1 = v1;

            for(uint64_t i=streakBegin; i!=streakEnd; i++) {
                const LinearChainInfo& linearChainInfo = linearChainInfos[i];
                const uint64_t linearChainId = linearChainInfo.linearChainId;
                const vector<edge_descriptor>& linearChain = linearChains[linearChainId];

                bubble.chains.resize(bubble.chains.size() + 1);
                vector<vertex_descriptor>& chain = bubble.chains.back();

                if(linearChain.size() > 1) {
                    for(uint64_t j=0; j<linearChain.size()-1; j++) {
                        const edge_descriptor e = linearChain[j];
                        const vertex_descriptor v = target(e, assemblyGraph2);
                        chain.push_back(v);
                    }
                }
            }
        }


        // Prepare to process the next streak.
        streakBegin = streakEnd;
    }

}



// Merge vertices in linear chains.
void AssemblyGraph2::compress()
{
    performanceLog << timestamp << "Compress begins." << endl;
    AssemblyGraph2& assemblyGraph2 = *this;

    // Find linear chains of vertices in the TransitionGraph.
    vector< vector<vertex_descriptor> > chains;
    findLinearVertexChains(assemblyGraph2, chains);

    // Each chain with more than one vertex is replaced with a single vertex.
    for(const vector<vertex_descriptor>& chain: chains) {
        if(chain.size() < 2) {
            continue;
        }

        // Create the new vertex.
        const vertex_descriptor vNew = add_vertex(AssemblyGraph2Vertex(nextVertexId++), assemblyGraph2);
        AssemblyGraph2Vertex& vertexNew = assemblyGraph2[vNew];
        for(const vertex_descriptor v: chain) {
            const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
            copy(vertex.begin(), vertex.end(), back_inserter(vertexNew));
        }

        // Create the edges to/from the new vertex.
        const vertex_descriptor v0 = chain.front();
        BGL_FORALL_INEDGES(v0, e, assemblyGraph2, AssemblyGraph2) {
            add_edge(source(e, assemblyGraph2), vNew, assemblyGraph2);
        }
        const vertex_descriptor v1 = chain.back();
        BGL_FORALL_OUTEDGES(v1, e, assemblyGraph2, AssemblyGraph2) {
            add_edge(vNew, target(e, assemblyGraph2), assemblyGraph2);
        }

        // Remove the old vertices.
        for(const vertex_descriptor v: chain) {
            clear_vertex(v, assemblyGraph2);
            remove_vertex(v, assemblyGraph2);
        }
    }
    performanceLog << timestamp << "Compress ends." << endl;

}



void AssemblyGraph2::clearSequence()
{
    AssemblyGraph2& assemblyGraph2 = *this;

    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
        vertex.wasAssembled= false;
        for(AssemblyGraph2VertexStep& step: assemblyGraph2[v]) {
            step.sequence.clear();
            step.sequence.shrink_to_fit();
        }
    }

}



void AssemblyGraph2::save(ostream& s) const
{
    boost::archive::binary_oarchive archive(s);
    archive << *this;
}



void AssemblyGraph2::load(istream& s)
{
    boost::archive::binary_iarchive archive(s);
    archive >> *this;
}



void AssemblyGraph2::save(const string& stage) const
{
    // If not using persistent binary data, do nothing.
    if(largeDataFileNamePrefix.empty()) {
        return;
    }

    // First save to a string.
    std::ostringstream s;
    save(s);
    const string dataString = s.str();

    // Now save the string to binary data.
    const string name = largeDataName("AssemblyGraph2-" + stage);
    MemoryMapped::Vector<char> data;
    data.createNew(name, largeDataPageSize);
    data.resize(dataString.size());
    const char* begin = dataString.data();
    const char* end = begin + dataString.size();
    copy(begin, end, data.begin());
}



void AssemblyGraph2::load(const string& assemblyStage)
{
    // Access the binary data.
    MemoryMapped::Vector<char> data;
    try {
        const string name = largeDataName("AssemblyGraph2-" + assemblyStage);
        data.accessExistingReadOnly(name);
    } catch (std::exception&) {
        throw runtime_error("Assembly graph at stage " + assemblyStage +
            " is not available.");
    }
    const string dataString(data.begin(), data.size());

    // Load it from here.
    std::istringstream s(dataString);
    try {
        load(s);
    } catch(std::exception& e) {
        throw runtime_error("Error reading assembly graph at stage " + assemblyStage +
            ": " + e.what());
    }
}



void AssemblyGraph2::detangleVertices(Detangler& detangler)
{
    AssemblyGraph2& assemblyGraph2 = *this;
    performanceLog << timestamp << "AssemblyGraph2::detangleVertices begins." << endl;

    // Gather all the vertices with more than one entrance and exit.
    // These are our detangling candidates.
    std::set<vertex_descriptor> detanglingCandidates;
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        const uint64_t entranceCount = in_degree (v, assemblyGraph2);
        const uint64_t exitCount     = out_degree(v, assemblyGraph2);
        if((entranceCount > 1) and (exitCount > 1)) {
            detanglingCandidates.insert(v);
        }
    }
    cout << "Found " << detanglingCandidates.size() <<
        " tangle vertices out of " << num_vertices(assemblyGraph2) << " total vertices." << endl;


    uint64_t attemptCount = 0;
    uint64_t successCount = 0;
    while(not detanglingCandidates.empty()) {
        auto it = detanglingCandidates.begin();
        const vertex_descriptor v = *it;
        detanglingCandidates.erase(it);

        // cout << "Attempting to detangle vertex " << assemblyGraph2[v].id << endl;

        ++attemptCount;
        Tangle2 tangle(assemblyGraph2, v,
            assemblerOptions.aDrift,
            assemblerOptions.bDrift);
        const bool success = detangler(tangle);
        if(success) {
            // cout << "Detangling successfull for vertex " << assemblyGraph2[v].id << endl;
            ++successCount;
            for(const vertex_descriptor v: tangle.removedVertices) {
                detanglingCandidates.erase(v);
            }
        } else {
            // cout << "Detangling failure for vertex " << assemblyGraph2[v].id << endl;
        }
    }

    performanceLog << timestamp << "AssemblyGraph2::detangleVertices ends." << endl;

    cout << "Attempted detangling for " << attemptCount << " tangle vertices." << endl;
    cout << "Detangling was successful for " << successCount << " tangle vertices." << endl;
}
