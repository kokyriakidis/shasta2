// Shasta.
#include "AssemblyGraph2.hpp"
#include "findLinearChains.hpp"
#include "TransitionGraph.hpp"
using namespace shasta;

// Standard library.
#include <fstream.hpp>
#include <list>
#include <map>



AssemblyGraph2::AssemblyGraph2(
    const Anchors& anchors,
    const AnchorGraph& anchorGraph,
    const TransitionGraph& transitionGraph)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    // Find linear chains of vertices in the TransitionGraph.
    vector< std::list<TransitionGraph::vertex_descriptor> > chains;
    findLinearVertexChains(transitionGraph, chains);
    cout << "Found " << chains.size() << " linear chains in the TransitionGraph." << endl;

    // Maps filled n while creating vertices and used to create edges.
    std::map<TransitionGraph::vertex_descriptor, AssemblyGraph2::vertex_descriptor> firstVertexMap;
    std::map<AssemblyGraph2::vertex_descriptor, TransitionGraph::vertex_descriptor> lastVertexMap;

    // Each chain generates an AssemblyGraph2Vertex.
    // To be able to create edges below, we keep a map that gives us the
    // AssemblyGraph2::vertex_descriptor corresponding to the chain
    // that begins at a given TransitionGraph::vertex-descriptor.
    for(const std::list<TransitionGraph::vertex_descriptor>& chain: chains) {
        const vertex_descriptor va = add_vertex(AssemblyGraph2Vertex(nextVertexId++), assemblyGraph2);
        AssemblyGraph2Vertex& vertex = assemblyGraph2[va];
        firstVertexMap.insert(make_pair(chain.front(), va));
        lastVertexMap.insert(make_pair(va, chain.back()));
        for(const TransitionGraph::vertex_descriptor vt: chain) {
            const AnchorGraph::edge_descriptor eAnchorGraph = transitionGraph[vt].eAnchorGraph;
            const AnchorPair& anchorPair = anchorGraph[eAnchorGraph];
            const uint64_t offset = anchorPair.getAverageOffset(anchors);
            vertex.push_back(AssemblyGraph2VertexStep(anchorPair, offset));
        }
    }
    chains.clear();
    chains.shrink_to_fit();


    // To generate edges, we loop over vertices and use the maps created above.
    BGL_FORALL_VERTICES(v0a, assemblyGraph2, AssemblyGraph2) {

        // Find the TransitionGraph vertex at the end of the chain than generated this vertex.
        auto itLast  = lastVertexMap.find(v0a);
        SHASTA_ASSERT(itLast != lastVertexMap.end());
        const TransitionGraph::vertex_descriptor v0t = itLast->second;

        // Loop over out-edges of v0t in the TransitionGraph.
        BGL_FORALL_OUTEDGES(v0t, e, transitionGraph, TransitionGraph) {
            const TransitionGraph::vertex_descriptor v1t = target(e, transitionGraph);

            // Find the AssemblyGraph2Vertex generated by the chain that begins here.
            auto itFirst  = firstVertexMap.find(v1t);
            SHASTA_ASSERT(itFirst != firstVertexMap.end());
            const AssemblyGraph2::vertex_descriptor v1a = itFirst->second;

            // Add the edge.
            add_edge(v0a, v1a, assemblyGraph2);
        }
    }

    cout << "The initial AssemblyGraph2 has " << num_vertices(assemblyGraph2) <<
        " vertices and " << num_edges(assemblyGraph2) << " edges." << endl;

}



void AssemblyGraph2::writeGfa(const string& fileName) const
{
    ofstream gfa(fileName);
    writeGfa(gfa);
}



void AssemblyGraph2::writeGfa(ostream& gfa) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    // Write the header line.
    gfa << "H\tVN:Z:1.0\n";

    // Eacg vertex generates a gfa segment.
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];

        // Record type.
        gfa << "S\t";

        // Name.
        gfa << vertex.id << "\t";

        // Sequence.
        gfa << "*\t";
        gfa << "LN:i:" << 100 * vertex.size() << "\n";   // For now
    }



    // Each edge generates a gfa link.
    BGL_FORALL_EDGES(e, assemblyGraph2, AssemblyGraph2) {

        const vertex_descriptor v0 = source(e, assemblyGraph2);
        const vertex_descriptor v1 = target(e, assemblyGraph2);

        const AssemblyGraph2Vertex& vertex0 = assemblyGraph2[v0];
        const AssemblyGraph2Vertex& vertex1 = assemblyGraph2[v1];

        gfa <<
            "L\t" <<
            vertex0.id << "\t+\t" <<
            vertex1.id << "\t+\t*\n";
    }

}
