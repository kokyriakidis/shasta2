// Shasta.
#include "AssemblyGraph2.hpp"
#include "Anchor.hpp"
#include "findLinearChains.hpp"
#include "LocalAssembly2.hpp"
#include "performanceLog.hpp"
#include "TransitionGraph.hpp"
using namespace shasta;

// Standard library.
#include <chrono.hpp>
#include <fstream.hpp>
#include <list>
#include <map>

// Explicit instantiationn.
#include "MultithreadedObject.tpp"
template class MultithreadedObject<AssemblyGraph2>;



AssemblyGraph2::AssemblyGraph2(
    const Anchors& anchors,
    const TransitionGraph& transitionGraph,
    double aDrift,
    double bDrift,
    uint64_t maxAbpoaLength) :
    MappedMemoryOwner(anchors),
    MultithreadedObject<AssemblyGraph2>(*this),
    anchors(anchors),
    aDrift(aDrift),
    bDrift(bDrift),
    maxAbpoaLength(maxAbpoaLength)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    // Find linear chains of vertices in the TransitionGraph.
    vector< std::list<TransitionGraph::vertex_descriptor> > chains;
    findLinearVertexChains(transitionGraph, chains);
    // cout << "Found " << chains.size() << " linear chains in the TransitionGraph." << endl;

    // Maps filled n while creating vertices and used to create edges.
    std::map<TransitionGraph::vertex_descriptor, AssemblyGraph2::vertex_descriptor> firstVertexMap;
    std::map<AssemblyGraph2::vertex_descriptor, TransitionGraph::vertex_descriptor> lastVertexMap;

    // Each chain generates an AssemblyGraph2Vertex.
    // To be able to create edges below, we keep a map that gives us the
    // AssemblyGraph2::vertex_descriptor corresponding to the chain
    // that begins at a given TransitionGraph::vertex-descriptor.
    for(const std::list<TransitionGraph::vertex_descriptor>& chain: chains) {
        const vertex_descriptor va = add_vertex(AssemblyGraph2Vertex(nextVertexId++), assemblyGraph2);
        AssemblyGraph2Vertex& vertex = assemblyGraph2[va];
        firstVertexMap.insert(make_pair(chain.front(), va));
        lastVertexMap.insert(make_pair(va, chain.back()));
        for(const TransitionGraph::vertex_descriptor vt: chain) {
            const AnchorPair& anchorPair = transitionGraph[vt].anchorPair;
            const uint64_t offset = anchorPair.getAverageOffset(anchors);
            vertex.push_back(AssemblyGraph2VertexStep(anchorPair, offset));
        }
    }
    chains.clear();
    chains.shrink_to_fit();


    // To generate edges, we loop over vertices and use the maps created above.
    BGL_FORALL_VERTICES(v0a, assemblyGraph2, AssemblyGraph2) {

        // Find the TransitionGraph vertex at the end of the chain than generated this vertex.
        auto itLast  = lastVertexMap.find(v0a);
        SHASTA_ASSERT(itLast != lastVertexMap.end());
        const TransitionGraph::vertex_descriptor v0t = itLast->second;

        // Loop over out-edges of v0t in the TransitionGraph.
        BGL_FORALL_OUTEDGES(v0t, e, transitionGraph, TransitionGraph) {
            const TransitionGraph::vertex_descriptor v1t = target(e, transitionGraph);

            // Find the AssemblyGraph2Vertex generated by the chain that begins here.
            auto itFirst  = firstVertexMap.find(v1t);
            SHASTA_ASSERT(itFirst != firstVertexMap.end());
            const AssemblyGraph2::vertex_descriptor v1a = itFirst->second;

            // Add the edge.
            add_edge(v0a, v1a, assemblyGraph2);
        }
    }

    cout << "The initial AssemblyGraph2 has " << num_vertices(assemblyGraph2) <<
        " vertices and " << num_edges(assemblyGraph2) << " edges." << endl;

    // Check that all vertices and edges of the TransitionGraph are accounted for.
    uint64_t vertexCount = 0;
    uint64_t edgeCount = num_edges(assemblyGraph2);
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        vertexCount += assemblyGraph2[v].size();
        edgeCount += (assemblyGraph2[v].size() - 1);
    }
    SHASTA_ASSERT(vertexCount == num_vertices(transitionGraph));
    SHASTA_ASSERT(edgeCount == num_edges(transitionGraph));

    // Check that all is good.
    check();
}



void AssemblyGraph2::check() const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        assemblyGraph2[v].check(anchors);
    }
    BGL_FORALL_EDGES(e, assemblyGraph2, AssemblyGraph2) {
        check(e);
    }
}



void AssemblyGraph2Vertex::check(const Anchors& anchors) const
{

    // The AnchorPairs of this vertex must be adjacent to each other.
    for(uint64_t i1=1; i1<size(); i1++) {
        const uint64_t i0 = i1 - 1;

        const AssemblyGraph2VertexStep& step0 = (*this)[i0];
        const AssemblyGraph2VertexStep& step1 = (*this)[i1];

        /*
        cout <<
            i0 << " " <<
            i1 << " " <<
            step0.anchorPair.anchorIdA << " " <<
            step0.anchorPair.anchorIdB << " " <<
            step1.anchorPair.anchorIdA << " " <<
            step1.anchorPair.anchorIdB << endl;
        */

        SHASTA_ASSERT(step0.anchorPair.anchorIdB == step1.anchorPair.anchorIdA);
    }

    // The offsets must be correct.
    for(const AssemblyGraph2VertexStep& step: *this) {
        SHASTA_ASSERT(step.offset == step.anchorPair.getAverageOffset(anchors));
    }
}



void AssemblyGraph2::check(edge_descriptor e) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    const vertex_descriptor v0 = source(e, assemblyGraph2);
    const vertex_descriptor v1 = target(e, assemblyGraph2);

    const AssemblyGraph2Vertex& vertex0 = assemblyGraph2[v0];
    const AssemblyGraph2Vertex& vertex1 = assemblyGraph2[v1];

    SHASTA_ASSERT(vertex0.back().anchorPair.anchorIdB == vertex1.front().anchorPair.anchorIdA);
}



void AssemblyGraph2::writeGfa(const string& fileName) const
{
    ofstream gfa(fileName);
    writeGfa(gfa);
}



void AssemblyGraph2::writeGfa(ostream& gfa) const
{
    const AssemblyGraph2& assemblyGraph2 = *this;

    // Write the header line.
    gfa << "H\tVN:Z:1.0\n";

    // Eacg vertex generates a gfa segment.
    vector<shasta::Base> sequence;
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        const AssemblyGraph2Vertex& vertex = assemblyGraph2[v];

        // Record type.
        gfa << "S\t";

        // Name.
        gfa << vertex.id << "\t";

        // Sequence.
        if(vertex.wasAssembled) {
            vertex.getSequence(sequence);
            copy(sequence.begin(), sequence.end(), ostream_iterator<shasta::Base>(gfa));
            gfa << "\t";
            gfa << "LN:i:" << sequence.size() << "\n";
        } else {
            gfa << "*\t";
            gfa << "LN:i:" << vertex.offset() << "\n";
        }
    }



    // Each edge generates a gfa link.
    BGL_FORALL_EDGES(e, assemblyGraph2, AssemblyGraph2) {

        const vertex_descriptor v0 = source(e, assemblyGraph2);
        const vertex_descriptor v1 = target(e, assemblyGraph2);

        const AssemblyGraph2Vertex& vertex0 = assemblyGraph2[v0];
        const AssemblyGraph2Vertex& vertex1 = assemblyGraph2[v1];

        gfa <<
            "L\t" <<
            vertex0.id << "\t+\t" <<
            vertex1.id << "\t+\t*\n";
    }

}



uint64_t AssemblyGraph2Vertex::offset() const
{
    uint64_t sum = 0;
    for(const AssemblyGraph2VertexStep& step: *this) {
        sum += step.offset;
    }
    return sum;
}



// Assemble sequence for all vertices.
void AssemblyGraph2::assembleAll(uint64_t threadCount)
{
    cout << timestamp << "Sequence assembly begins." << endl;
    const AssemblyGraph2& assemblyGraph2 = *this;

    verticesToBeAssembled.clear();
    BGL_FORALL_VERTICES(v, assemblyGraph2, AssemblyGraph2) {
        verticesToBeAssembled.push_back(v);
    }
    assemble(threadCount);
    cout << timestamp << "Sequence assembly ends." << endl;
}



// Assemble sequence for all vertices in the verticesToBeAssembled vector.
// This fills in the stepsToBeAssembled with all steps of those edges,
// then assembles each of the steps in parallel.
void AssemblyGraph2::assemble(uint64_t threadCount)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    stepsToBeAssembled.clear();
    for(const vertex_descriptor v: verticesToBeAssembled) {
        AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
        for(uint64_t i=0; i<vertex.size(); i++) {
            stepsToBeAssembled.push_back(make_pair(v, i));
        }
    }

    const uint64_t batchCount = 1;
    setupLoadBalancing(stepsToBeAssembled.size(), batchCount);
    runThreads(&AssemblyGraph2::assembleThreadFunction, threadCount);

    // Mark them as assembled.
    for(const vertex_descriptor v: verticesToBeAssembled) {
        assemblyGraph2[v].wasAssembled = true;
    }

    verticesToBeAssembled.clear();
    stepsToBeAssembled.clear();
}



void AssemblyGraph2::assembleThreadFunction(uint64_t threadId)
{
    AssemblyGraph2& assemblyGraph2 = *this;

    ofstream out("Assemble-Thread-" + to_string(threadId) + ".txt");

    // Loop over all batches assigned to this thread.
    uint64_t begin, end;
    while(getNextBatch(begin, end)) {

        // Loop over all assembly steps assigned to this batch.
        for(uint64_t j=begin; j!=end; j++) {
            if((j % 1000) == 0) {
                std::lock_guard<std::mutex> lock(mutex);
                performanceLog << timestamp << j << "/" << stepsToBeAssembled.size() << endl;
            }

            const auto& p = stepsToBeAssembled[j];
            const vertex_descriptor v = p.first;
            const uint64_t i = p.second;
            AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
            SHASTA_ASSERT(i < vertex.size());
            out << "Begin " << vertex.id << "," << i << endl;
            const auto t0 = steady_clock::now();
            assembleStep(v, i);
            const auto t1 = steady_clock::now();
            out << "End " << vertex.id << "," << i << "," << seconds(t1-t0) << endl;
        }
    }
}



// Assemble sequence for the specified vertex.
void AssemblyGraph2::assemble(vertex_descriptor v, uint64_t threadCount)
{
    verticesToBeAssembled.clear();
    verticesToBeAssembled.push_back(v);
    assemble(threadCount);
}



// Assemble sequence for step i of the specified vertex.
// This is the lowest level sequence assembly function and is not multithreaded.
// It runs a LocalAssembly2 on the AnchorPair for that step.
void AssemblyGraph2::assembleStep(vertex_descriptor v, uint64_t i)
{
    AssemblyGraph2& assemblyGraph2 = *this;
    AssemblyGraph2Vertex& vertex = assemblyGraph2[v];
    AssemblyGraph2VertexStep& step = vertex[i];

    // Run the LocalAssembly2.
    ofstream html;  // Not open, so no html output takes place.
    LocalAssembly2 localAssembly(
        anchors, html, false,
        aDrift,
        bDrift,
        step.anchorPair);
    localAssembly.run(false, maxAbpoaLength);
    localAssembly.getSequence(step.sequence);

}



void AssemblyGraph2Vertex::getSequence(vector<Base>& sequence) const
{
    sequence.clear();
    for(const auto& step: *this) {
        copy(step.sequence.begin(), step.sequence.end(), back_inserter(sequence));
    }
}
